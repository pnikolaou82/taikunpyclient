# coding: utf-8

"""
    Taikun - WebApi

    This Api will be responsible for overall data distribution and authorization.

    The version of the OpenAPI document: v1
    Contact: noreply@taikun.cloud
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from taikunpycore.models.project_common_record_dto import ProjectCommonRecordDto
from typing import Optional, Set
from typing_extensions import Self

class ProjectChartDto(BaseModel):
    """
    ProjectChartDto
    """ # noqa: E501
    succeeded: Optional[List[ProjectCommonRecordDto]] = None
    updating: Optional[List[ProjectCommonRecordDto]] = None
    total_count: Optional[StrictInt] = Field(default=None, alias="totalCount")
    failed: Optional[List[ProjectCommonRecordDto]] = None
    purging: Optional[List[ProjectCommonRecordDto]] = None
    deleting: Optional[List[ProjectCommonRecordDto]] = None
    importing: Optional[List[ProjectCommonRecordDto]] = None
    failed_to_import: Optional[List[ProjectCommonRecordDto]] = Field(default=None, alias="failedToImport")
    __properties: ClassVar[List[str]] = ["succeeded", "updating", "totalCount", "failed", "purging", "deleting", "importing", "failedToImport"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ProjectChartDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in succeeded (list)
        _items = []
        if self.succeeded:
            for _item_succeeded in self.succeeded:
                if _item_succeeded:
                    _items.append(_item_succeeded.to_dict())
            _dict['succeeded'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in updating (list)
        _items = []
        if self.updating:
            for _item_updating in self.updating:
                if _item_updating:
                    _items.append(_item_updating.to_dict())
            _dict['updating'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in failed (list)
        _items = []
        if self.failed:
            for _item_failed in self.failed:
                if _item_failed:
                    _items.append(_item_failed.to_dict())
            _dict['failed'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in purging (list)
        _items = []
        if self.purging:
            for _item_purging in self.purging:
                if _item_purging:
                    _items.append(_item_purging.to_dict())
            _dict['purging'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in deleting (list)
        _items = []
        if self.deleting:
            for _item_deleting in self.deleting:
                if _item_deleting:
                    _items.append(_item_deleting.to_dict())
            _dict['deleting'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in importing (list)
        _items = []
        if self.importing:
            for _item_importing in self.importing:
                if _item_importing:
                    _items.append(_item_importing.to_dict())
            _dict['importing'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in failed_to_import (list)
        _items = []
        if self.failed_to_import:
            for _item_failed_to_import in self.failed_to_import:
                if _item_failed_to_import:
                    _items.append(_item_failed_to_import.to_dict())
            _dict['failedToImport'] = _items
        # set to None if succeeded (nullable) is None
        # and model_fields_set contains the field
        if self.succeeded is None and "succeeded" in self.model_fields_set:
            _dict['succeeded'] = None

        # set to None if updating (nullable) is None
        # and model_fields_set contains the field
        if self.updating is None and "updating" in self.model_fields_set:
            _dict['updating'] = None

        # set to None if failed (nullable) is None
        # and model_fields_set contains the field
        if self.failed is None and "failed" in self.model_fields_set:
            _dict['failed'] = None

        # set to None if purging (nullable) is None
        # and model_fields_set contains the field
        if self.purging is None and "purging" in self.model_fields_set:
            _dict['purging'] = None

        # set to None if deleting (nullable) is None
        # and model_fields_set contains the field
        if self.deleting is None and "deleting" in self.model_fields_set:
            _dict['deleting'] = None

        # set to None if importing (nullable) is None
        # and model_fields_set contains the field
        if self.importing is None and "importing" in self.model_fields_set:
            _dict['importing'] = None

        # set to None if failed_to_import (nullable) is None
        # and model_fields_set contains the field
        if self.failed_to_import is None and "failed_to_import" in self.model_fields_set:
            _dict['failedToImport'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ProjectChartDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "succeeded": [ProjectCommonRecordDto.from_dict(_item) for _item in obj["succeeded"]] if obj.get("succeeded") is not None else None,
            "updating": [ProjectCommonRecordDto.from_dict(_item) for _item in obj["updating"]] if obj.get("updating") is not None else None,
            "totalCount": obj.get("totalCount"),
            "failed": [ProjectCommonRecordDto.from_dict(_item) for _item in obj["failed"]] if obj.get("failed") is not None else None,
            "purging": [ProjectCommonRecordDto.from_dict(_item) for _item in obj["purging"]] if obj.get("purging") is not None else None,
            "deleting": [ProjectCommonRecordDto.from_dict(_item) for _item in obj["deleting"]] if obj.get("deleting") is not None else None,
            "importing": [ProjectCommonRecordDto.from_dict(_item) for _item in obj["importing"]] if obj.get("importing") is not None else None,
            "failedToImport": [ProjectCommonRecordDto.from_dict(_item) for _item in obj["failedToImport"]] if obj.get("failedToImport") is not None else None
        })
        return _obj


